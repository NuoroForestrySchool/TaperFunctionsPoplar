---
title: "Modelling tree and 'Treat' effect on detailed profiles comparison"
output: html_notebook
---
# Intro
Analysis of differences (or ratios) between orthogonal tree profiles implies a nested design:  
.*. measurements from the same tree are not 'independent' observations!  
Differences (and ratios) are also dependent on 'section height'.  
Here we focus on the most convenient way to model that relation.  
The graph is generally 'U' shaped, hence a straight line is particularly inefficient as a model.  
Since the 'U' is not symmetrical, a polynomial of order grather than 2 could be required.  
Selection of model variables is performed adopting a stepwise procedure.  

```{r}
source("DataWrangling.R")

fm4 <- lm(data=stff, delta_d_cm ~ poly(Sect_height,4) * TreeId)

# First we try the classical 'p' based (or 'F' based) stepwise procedure (pent = 0.1, prem = 0.3)  

#   ols_step_both_p(fm4)

# Not working!! it doesn't recognize the distinct powers as variables!

## Stepwise Selection Method   
## ---------------------------
## Candidate Terms: 
## 1. poly(Sect_height, 4) 
## 2. TreeId 
## 3. poly(Sect_height, 4):TreeId 
## We are selecting variables based on p value...

# Limited to power 2, ------------------------\|/
fp <- lm(data=stff, delta_d_cm ~ TreeId 
         +  Sect_height     * TreeId
         + I(Sect_height^2) * TreeId 
         + I(Sect_height^3) * TreeId )  # with this "ols_step_both_p" crashes
# (ols_step_both_p(fp)) %>% plot()

# Swithching to AIC based selection

ft <- lm(data=stff, delta_d_cm ~ TreeId 
         +  Sect_height     * TreeId
         + I(Sect_height^2) * TreeId 
         + I(Sect_height^3) * TreeId 
         + I(Sect_height^4) * TreeId 
         + I(Sect_height^5) * TreeId 
         + I(Sect_height^6) * TreeId 
         + I(Sect_height^7) * TreeId 
         + I(Sect_height^8) * TreeId 
         + I(Sect_height^9) * TreeId 
         )
ol <- ols_step_both_aic(ft)
plot(ol)  # labels 

ol[-3] %>% 
  as.data.frame() %>% 
  ggplot(aes(x = 1:ol[[3]], y = aic, label = predictors)) +
    ggtitle("Stepwise AIC Both Directions Selection") +
    geom_line() + 
    geom_point() +
    geom_text(angle = 20, hjust = 0, vjust = 0) + xlab("step") +
    xlim(c(1, ol[[3]] + 1)) +
    ylim(c(pretty(ol$aic)[1], pretty(max(ol$aic) * 1.05)[2]))

opt_m_f <- paste0("delta_d_cm ~ ", paste(ol$predictors[1:5], collapse = " + "))

```

Over power 4, it is alwais the highest power available that is selected.
It is probably due to local irregularities that the model should not consider.
Best model is hence the following:
.*.  `r opt_m_f`
```{r}

opt_m <- lm(data=stff, opt_m_f)

stff %>% ggplot(aes(x = Sect_height, y = delta_d_cm)) +
  geom_point() +
  geom_smooth() +
  geom_line(aes(x = Sect_height, y = fitted(opt_m)), color = "yellow", size = 1) + 
  facet_wrap(~TreeId)

# Actually even power 4 could be in too high, some bendings are in excess

# Insted of wrangling with opt_m estimates,
# it is more straightforward to recompute power 4 poly coefficients estimates for each tree

l1p <- stff %>%
  group_by(TreeId) %>%
  do(fit = tidy(lm(delta_d_cm ~ poly(Sect_height, 4), .))) %>%
  unnest() %>%
  select(1:3) %>%
  inner_join(unique(stff[, c("Treat", "TreeId")]))
    
```

# Evaluation of the effect of Treat on level 1 (tree level) parameters

```{r}

l1p %>%
  spread(term, estimate) %>%
  select(3:7) %>%
  cor()

# evaluations disregarding coefficients standard deviation

# separate evaluations, one for each delta_d=f(Sect_height) function coefficient
l1p %>%
  group_by(term) %>%
  do(fit = tidy(anova(lm(estimate ~ Treat, .)))) %>%
  unnest()
# p.values >> .1

# joint evaluation of all delta_d=f(Sect_height) function coefficients for each tree
l1p %>% lm(estimate ~ Treat * term, .) %>% anova()

f0 <- lmer(estimate ~     1 + (1 | term), l1p)
f1 <- lmer(estimate ~ Treat + (1 | term), l1p)
anova(f0, f1)
# No effect! Pr(>Chisq) = 0.6836 !!

```


[rmarkdown::render("PiecewiseEvaluation.Rmd", encoding="UTF-8")]
